import { Immutable } from 'immer';
import {
	APPEARANCE_POSE_DEFAULT,
	Assert,
	BitField,
	CalculatePointsTrianglesFlat,
	CloneDeepMutable,
	Item,
	LayerImageSetting,
	MakeMirroredPoints,
	PointDefinition,
	ProduceAppearancePose,
	type AppearancePose,
	type GraphicsLayer,
	type PointDefinitionCalculated,
	type PointTemplate,
} from 'pandora-common';
import { useMemo } from 'react';
import { Base64ToArray } from '../crypto/helpers.ts';
import { AppearanceConditionEvaluator } from '../graphics/appearanceConditionEvaluator.ts';
import { GRAPHICS_TEXTURE_RESOLUTION_SCALE, useGraphicsSettings } from '../graphics/graphicsSettings.tsx';
import { EvaluateCondition } from '../graphics/utility.ts';
import { useObservable } from '../observable.ts';
import { useAutomaticResolution } from '../services/screenResolution/screenResolutionHooks.ts';
import { GraphicsManagerInstance } from './graphicsManager.ts';

export function useLayerImageSource(
	evaluator: AppearanceConditionEvaluator,
	{ image: setting }: Pick<Immutable<Extract<GraphicsLayer, { type: 'mesh'; }>>, 'image'>,
	item: Item | null,
): Immutable<{ setting: Immutable<LayerImageSetting>; image: string; normalMapImage?: string; imageUvPose: Immutable<AppearancePose>; }> {
	return useMemo((): ReturnType<typeof useLayerImageSource> => {
		const resultSetting = setting.overrides.find((img) => EvaluateCondition(img.condition, (c) => evaluator.evalCondition(c, item))) ?? setting;

		return {
			setting,
			image: resultSetting.image,
			normalMapImage: resultSetting.normalMapImage,
			imageUvPose: resultSetting.uvPose ? ProduceAppearancePose(
				APPEARANCE_POSE_DEFAULT,
				{ assetManager: evaluator.poseEvaluator.assetManager },
				resultSetting.uvPose,
			) : APPEARANCE_POSE_DEFAULT,
		};
	}, [evaluator, item, setting]);
}

const calculatedPointsCache = new WeakMap<Immutable<PointDefinition[]>, Immutable<PointDefinitionCalculated[]>>();
export function CalculatePointDefinitionsFromTemplate(template: Immutable<PointTemplate>): Immutable<PointDefinitionCalculated[]> {
	let result: Immutable<PointDefinitionCalculated[]> | undefined = calculatedPointsCache.get(template);
	if (result === undefined) {
		result = template
			.map((point, index): PointDefinitionCalculated => ({
				...CloneDeepMutable(point),
				index,
				isMirror: false,
			}))
			.flatMap(MakeMirroredPoints);
		calculatedPointsCache.set(template, result);
	}
	return result;
}

export function useLayerMeshPoints({ points, pointType, pointFilterMask }: Pick<Immutable<Extract<GraphicsLayer, { type: 'mesh'; }>>, 'points' | 'pointType' | 'pointFilterMask'>): {
	readonly points: Immutable<PointDefinitionCalculated[]>;
	readonly triangles: Uint32Array;
} {
	// Note: The points should NOT be filtered before Delaunator step!
	// Doing so would cause body and arms not to have exactly matching triangles,
	// causing (most likely) overlap, which would result in clipping.
	// In some other cases this could lead to gaps or other visual artifacts
	// Any optimization of unused points needs to be done *after* triangles are calculated
	const manager = useObservable(GraphicsManagerInstance);

	return useMemo((): ReturnType<typeof useLayerMeshPoints> => {
		const p = manager?.getTemplate(points);
		if (!p) {
			throw new Error(`Unknown template '${p}'`);
		}

		const calculatedPoints = CalculatePointDefinitionsFromTemplate(p);
		Assert(calculatedPoints.length < 65535, 'Points do not fit into indices');

		const pointsFilter = new BitField(calculatedPoints.length);
		for (let i = 0; i < calculatedPoints.length; i++) {
			pointsFilter.set(i, pointType == null || pointType.includes(calculatedPoints[i].pointType));
		}

		// Point filter based on binary mask (generated by asset repo during optimizations)
		if (pointFilterMask != null) {
			const pointFilterMaskData = new BitField(Base64ToArray(pointFilterMask));
			for (let i = 0; i < calculatedPoints.length; i++) {
				if (!pointFilterMaskData.get(i)) {
					pointsFilter.set(i, false);
				}
			}
		}

		return {
			points: calculatedPoints,
			triangles: CalculatePointsTrianglesFlat(calculatedPoints, pointsFilter),
		};
	}, [manager, points, pointType, pointFilterMask]);
}

export function useGraphicsTextureResolution() {
	const { textureResolution } = useGraphicsSettings();
	const automaticResolution = useAutomaticResolution();
	const finalTextureResolution = textureResolution === 'auto' ? automaticResolution : textureResolution;

	return finalTextureResolution;
}

export function useImageResolutionAlternative(image: string): {
	image: string;
	resolution: number;
	scale: number;
} {
	const textureResolution = useGraphicsTextureResolution();

	const EXTENSIONS = ['.png', '.jpg'];

	for (const ext of EXTENSIONS) {
		if (image.endsWith(ext)) {
			if (textureResolution !== '1') {
				return {
					image: image.substring(0, image.length - ext.length) + `_r${textureResolution}${ext}`,
					resolution: 1 / GRAPHICS_TEXTURE_RESOLUTION_SCALE[textureResolution],
					scale: GRAPHICS_TEXTURE_RESOLUTION_SCALE[textureResolution],
				};
			}
		}
	}

	return {
		image,
		resolution: 1,
		scale: 1,
	};
}
