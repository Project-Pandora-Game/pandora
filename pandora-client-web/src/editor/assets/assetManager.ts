import { downloadZip, InputWithSizeMeta } from 'client-zip';
import { Assert, Asset, AssetDefinition, AssetGraphicsDefinition, AssetId, AssetsDefinitionFile } from 'pandora-common';
import { AssetManagerClient, OverrideAssetManager, GetAssetManager as GetAssetManagerClient } from '../../assets/assetManager';
import { observable, ObservableClass } from '../../observable';

export const ASSET_ID_PART_REGEX = /^[a-z][a-z0-9]*([-_][a-z0-9]+)*$/;

export class AssetManagerEditor extends AssetManagerClient {

	public readonly assetTreeView: AssetTreeView = new AssetTreeViewClass;

	public override load(definitionsHash: string, data: AssetsDefinitionFile): void {
		super.load(definitionsHash, data);
		this.assetTreeView.update(this.getAllAssets());
	}

	public async createNewAsset(category: string, idPart: string, name: string, bodypart: string): Promise<void> {
		const id: AssetId = `a/${category}/${idPart}`;

		Assert(ASSET_ID_PART_REGEX.test(category));
		Assert(ASSET_ID_PART_REGEX.test(idPart));
		Assert(!this.getAssetById(id));
		Assert(!bodypart || this.bodyparts.some((b) => b.name === bodypart));

		const definition: AssetDefinition = {
			id,
			name,
			size: bodypart ? 'bodypart' : 'medium',
			bodypart: bodypart ? bodypart : undefined,
			colorization: {
				base: {
					name: 'Color group',
					default: '#FFFFFF',
				},
			},
			hasGraphics: false,
		};

		const asset = this.createAsset(id, definition);
		this._assets.set(id, asset);

		// Download the definition
		const assetTemplateContent = `
// The comments provide info about what is REQUIRED before submitting an asset.
// After filling the info in, please remove the helper comments before creating a PR.

DefineAsset({
	// Name of your asset, this is what users see
	name: '${name}',${bodypart ? `\n\tbodypart: '${bodypart}',` : ''}
	// Size of this item. Affects mainly which things it can fit into. For more details check pandora-common/src/assets/definitions.ts
	size: '${bodypart ? 'bodypart' : 'medium'}',
	// Name of the file with graphics created using Editor.
	graphics: 'graphics.json',
	// Definitions of how your asset should be colorable.
	// Rename the example group or copy it to add more independent ones.
	colorization: [
		{
			name: 'Color group',
			default: '#FFFFFF',
		},
	],
	// Info about who owns the asset(s)
	ownership: {
		// Same as the author of git commits present in PR, has responsibility for this asset
		responsibleContributor: 'gitName <gitEmail@example.com>',
		// Who is shown in the credits for this asset and at the same time the people to ask when this asset should be changed
		// Note: It does not have to be the gitName, but it may make it easier to get in contact
		credits: ['CHANGE_ME'],
		// Write your preference on how you want to allow others to modify this asset.
		// See more details in CONTRIBUTING.md
		modificationPolicy: 'Fixes and New uses, otherwise ask',
		// Write your preference on how you want to allow others to reuse parts of your assets for their assets,
		// See more details in CONTRIBUTING.md
		reusePolicy: 'Ask first',
		// Legal info about the images
		// If there are multiple sources used, specify this multiple times
		// If the author gave you express permission to use images but wishes to remain Anonymous, write "Anonymous" in relevant fields.
		licensing: [
			{
				// Which part of the asset does this part of licensing apply to?
				// This property is optional, if this applies to the whole asset, simply remove the line with \`part\`.
				// Examples: The chains; The main body of the asset without decorations; The decorations
				part: 'CHANGE_ME',
				// From where does the images come? An HTTP link to the source.
				// Can be 'Self-Made' for assets you created yourself or 'Private' for images acquired by directly communicating with the creator.
				source: 'Private',
				// Who is the copyright holder of the original images? The name they go by.
				copyrightHolder: 'CHANGE_ME',
				// Who edited the images to work for Pandora? It can be the same as \`copyrightHolder\`.
				editedBy: 'CHANGE_ME',
				// License; see possible licenses in ASSET_LICENSING.md file.
				// Alternatively, write the name of the file with the license prefixed by \`./\` (e.g. \`./LICENSE.md\`)
				license: 'Pandora-Use-Only',
			},
		],
	},
});
`.trim() + '\n';

		const baseGraphics: AssetGraphicsDefinition = {
			layers: [],
		};
		const graphicsDefinitionContent = `// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n`
			+ JSON.stringify(baseGraphics, undefined, '\t').trim()
			+ '\n';

		const now = new Date();

		const files: InputWithSizeMeta[] = [
			{ name: `assets/${category}/${idPart}/${idPart}.asset.ts`, lastModified: now, input: assetTemplateContent },
			{ name: `assets/${category}/${idPart}/graphics.json`, lastModified: now, input: graphicsDefinitionContent },
		];

		// get the ZIP stream in a Blob
		const blob = await downloadZip(files).blob();

		// make and click a temporary link to download the Blob
		const link = document.createElement('a');
		link.href = URL.createObjectURL(blob);
		link.download = `${id.replace(/^a\//, '').replaceAll('/', '_')}_template.zip`;
		link.style.display = 'none';
		document.body.appendChild(link);
		link.click();
		link.remove();
	}
}

let loaded = false;

export function GetAssetManagerEditor(): AssetManagerEditor {
	if (!loaded) {
		OverrideAssetManager(new AssetManagerEditor());
		loaded = true;
	}
	return GetAssetManagerClient() as AssetManagerEditor;
}

export type AssetTreeView = AssetTreeViewClass;
class AssetTreeViewClass {
	private readonly _categories = new Map<string, AssetTreeViewCategory>();

	public get categories(): AssetTreeViewCategory[] {
		return [...this._categories.values()];
	}

	public update(assets: Asset[]) {
		this._categories.clear();
		for (const asset of assets) {
			const [, category, name] = /^a\/([^/]+)\/([^/]+)$/.exec(asset.id) || [];
			if (!category || !name)
				continue;

			let categoryTreeView = this._categories.get(category);
			if (!categoryTreeView) {
				this._categories.set(category, categoryTreeView = new AssetTreeViewCategoryClass(category));
			}
			categoryTreeView.set(name, asset);
		}
	}
}

export type AssetTreeViewCategory = AssetTreeViewCategoryClass;
class AssetTreeViewCategoryClass extends ObservableClass<{ open: boolean; }> {
	private _assets = new Map<string, Asset>();

	public get assets(): Asset[] {
		return [...this._assets.values()];
	}
	public readonly name: string;

	@observable
	public open: boolean = false;

	constructor(name: string) {
		super();
		this.name = name;
	}

	public set(name: string, asset: Asset) {
		this._assets.set(name, asset);
	}
}
